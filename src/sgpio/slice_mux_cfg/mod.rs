#[doc = r" Value read from the register"]
pub struct R {
    bits: u32,
}
#[doc = r" Value to write to the register"]
pub struct W {
    bits: u32,
}
impl super::SLICE_MUX_CFG {
    #[doc = r" Modifies the contents of the register"]
    #[inline]
    pub fn modify<F>(&self, f: F)
    where
        for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
    {
        let bits = self.register.get();
        let r = R { bits: bits };
        let mut w = W { bits: bits };
        f(&r, &mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Reads the contents of the register"]
    #[inline]
    pub fn read(&self) -> R {
        R {
            bits: self.register.get(),
        }
    }
    #[doc = r" Writes to the register"]
    #[inline]
    pub fn write<F>(&self, f: F)
    where
        F: FnOnce(&mut W) -> &mut W,
    {
        let mut w = W::reset_value();
        f(&mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Writes the reset value to the register"]
    #[inline]
    pub fn reset(&self) {
        self.write(|w| w)
    }
}
#[doc = "Possible values of the field `MATCH_MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum MATCH_MODER {
    #[doc = "Do not match data."]
    DO_NOT_MATCH_DATA,
    #[doc = "Match data."]
    MATCH_DATA,
}
impl MATCH_MODER {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            MATCH_MODER::DO_NOT_MATCH_DATA => false,
            MATCH_MODER::MATCH_DATA => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> MATCH_MODER {
        match value {
            false => MATCH_MODER::DO_NOT_MATCH_DATA,
            true => MATCH_MODER::MATCH_DATA,
        }
    }
    #[doc = "Checks if the value of the field is `DO_NOT_MATCH_DATA`"]
    #[inline]
    pub fn is_do_not_match_data(&self) -> bool {
        *self == MATCH_MODER::DO_NOT_MATCH_DATA
    }
    #[doc = "Checks if the value of the field is `MATCH_DATA`"]
    #[inline]
    pub fn is_match_data(&self) -> bool {
        *self == MATCH_MODER::MATCH_DATA
    }
}
#[doc = "Possible values of the field `CLK_CAPTURE_MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum CLK_CAPTURE_MODER {
    #[doc = "Use rising clock edge."]
    USE_RISING_CLOCK_EDG,
    #[doc = "Use falling clock edge."]
    USE_FALLING_CLOCK_ED,
}
impl CLK_CAPTURE_MODER {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            CLK_CAPTURE_MODER::USE_RISING_CLOCK_EDG => false,
            CLK_CAPTURE_MODER::USE_FALLING_CLOCK_ED => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> CLK_CAPTURE_MODER {
        match value {
            false => CLK_CAPTURE_MODER::USE_RISING_CLOCK_EDG,
            true => CLK_CAPTURE_MODER::USE_FALLING_CLOCK_ED,
        }
    }
    #[doc = "Checks if the value of the field is `USE_RISING_CLOCK_EDG`"]
    #[inline]
    pub fn is_use_rising_clock_edg(&self) -> bool {
        *self == CLK_CAPTURE_MODER::USE_RISING_CLOCK_EDG
    }
    #[doc = "Checks if the value of the field is `USE_FALLING_CLOCK_ED`"]
    #[inline]
    pub fn is_use_falling_clock_ed(&self) -> bool {
        *self == CLK_CAPTURE_MODER::USE_FALLING_CLOCK_ED
    }
}
#[doc = "Possible values of the field `CLKGEN_MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum CLKGEN_MODER {
    #[doc = "Use clock internally generated by COUNTER."]
    USE_CLOCK_INTERNALLY,
    #[doc = "Use external clock from a pin or other slice."]
    USE_EXTERNAL_CLOCK_F,
}
impl CLKGEN_MODER {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            CLKGEN_MODER::USE_CLOCK_INTERNALLY => false,
            CLKGEN_MODER::USE_EXTERNAL_CLOCK_F => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> CLKGEN_MODER {
        match value {
            false => CLKGEN_MODER::USE_CLOCK_INTERNALLY,
            true => CLKGEN_MODER::USE_EXTERNAL_CLOCK_F,
        }
    }
    #[doc = "Checks if the value of the field is `USE_CLOCK_INTERNALLY`"]
    #[inline]
    pub fn is_use_clock_internally(&self) -> bool {
        *self == CLKGEN_MODER::USE_CLOCK_INTERNALLY
    }
    #[doc = "Checks if the value of the field is `USE_EXTERNAL_CLOCK_F`"]
    #[inline]
    pub fn is_use_external_clock_f(&self) -> bool {
        *self == CLKGEN_MODER::USE_EXTERNAL_CLOCK_F
    }
}
#[doc = "Possible values of the field `INV_OUT_CLK`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum INV_OUT_CLKR {
    #[doc = "Normal clock."]
    NORMAL_CLOCK,
    #[doc = "Inverted clock."]
    INVERTED_CLOCK,
}
impl INV_OUT_CLKR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            INV_OUT_CLKR::NORMAL_CLOCK => false,
            INV_OUT_CLKR::INVERTED_CLOCK => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> INV_OUT_CLKR {
        match value {
            false => INV_OUT_CLKR::NORMAL_CLOCK,
            true => INV_OUT_CLKR::INVERTED_CLOCK,
        }
    }
    #[doc = "Checks if the value of the field is `NORMAL_CLOCK`"]
    #[inline]
    pub fn is_normal_clock(&self) -> bool {
        *self == INV_OUT_CLKR::NORMAL_CLOCK
    }
    #[doc = "Checks if the value of the field is `INVERTED_CLOCK`"]
    #[inline]
    pub fn is_inverted_clock(&self) -> bool {
        *self == INV_OUT_CLKR::INVERTED_CLOCK
    }
}
#[doc = "Possible values of the field `DATA_CAPTURE_MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DATA_CAPTURE_MODER {
    #[doc = "Detect rising edge."]
    DETECT_RISING_EDGE,
    #[doc = "Detect falling edge."]
    DETECT_FALLING_EDGE,
    #[doc = "Detect LOW level."]
    DETECT_LOW_LEVEL,
    #[doc = "Detect HIGH level."]
    DETECT_HIGH_LEVEL,
}
impl DATA_CAPTURE_MODER {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        match *self {
            DATA_CAPTURE_MODER::DETECT_RISING_EDGE => 0,
            DATA_CAPTURE_MODER::DETECT_FALLING_EDGE => 1,
            DATA_CAPTURE_MODER::DETECT_LOW_LEVEL => 2,
            DATA_CAPTURE_MODER::DETECT_HIGH_LEVEL => 3,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: u8) -> DATA_CAPTURE_MODER {
        match value {
            0 => DATA_CAPTURE_MODER::DETECT_RISING_EDGE,
            1 => DATA_CAPTURE_MODER::DETECT_FALLING_EDGE,
            2 => DATA_CAPTURE_MODER::DETECT_LOW_LEVEL,
            3 => DATA_CAPTURE_MODER::DETECT_HIGH_LEVEL,
            _ => unreachable!(),
        }
    }
    #[doc = "Checks if the value of the field is `DETECT_RISING_EDGE`"]
    #[inline]
    pub fn is_detect_rising_edge(&self) -> bool {
        *self == DATA_CAPTURE_MODER::DETECT_RISING_EDGE
    }
    #[doc = "Checks if the value of the field is `DETECT_FALLING_EDGE`"]
    #[inline]
    pub fn is_detect_falling_edge(&self) -> bool {
        *self == DATA_CAPTURE_MODER::DETECT_FALLING_EDGE
    }
    #[doc = "Checks if the value of the field is `DETECT_LOW_LEVEL`"]
    #[inline]
    pub fn is_detect_low_level(&self) -> bool {
        *self == DATA_CAPTURE_MODER::DETECT_LOW_LEVEL
    }
    #[doc = "Checks if the value of the field is `DETECT_HIGH_LEVEL`"]
    #[inline]
    pub fn is_detect_high_level(&self) -> bool {
        *self == DATA_CAPTURE_MODER::DETECT_HIGH_LEVEL
    }
}
#[doc = "Possible values of the field `PARALLEL_MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum PARALLEL_MODER {
    #[doc = "Shift 1 bit per clock."]
    SHIFT_1_BIT_PER_CLOC,
    #[doc = "Shift 2 bits per clock."]
    SHIFT_2_BITS_PER_CLO,
    #[doc = "Shift 4 bits per clock."]
    SHIFT_4_BITS_PER_CLO,
    #[doc = "Shift 1 byte per clock."]
    SHIFT_1_BYTE_PER_CLO,
}
impl PARALLEL_MODER {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        match *self {
            PARALLEL_MODER::SHIFT_1_BIT_PER_CLOC => 0,
            PARALLEL_MODER::SHIFT_2_BITS_PER_CLO => 1,
            PARALLEL_MODER::SHIFT_4_BITS_PER_CLO => 2,
            PARALLEL_MODER::SHIFT_1_BYTE_PER_CLO => 3,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: u8) -> PARALLEL_MODER {
        match value {
            0 => PARALLEL_MODER::SHIFT_1_BIT_PER_CLOC,
            1 => PARALLEL_MODER::SHIFT_2_BITS_PER_CLO,
            2 => PARALLEL_MODER::SHIFT_4_BITS_PER_CLO,
            3 => PARALLEL_MODER::SHIFT_1_BYTE_PER_CLO,
            _ => unreachable!(),
        }
    }
    #[doc = "Checks if the value of the field is `SHIFT_1_BIT_PER_CLOC`"]
    #[inline]
    pub fn is_shift_1_bit_per_cloc(&self) -> bool {
        *self == PARALLEL_MODER::SHIFT_1_BIT_PER_CLOC
    }
    #[doc = "Checks if the value of the field is `SHIFT_2_BITS_PER_CLO`"]
    #[inline]
    pub fn is_shift_2_bits_per_clo(&self) -> bool {
        *self == PARALLEL_MODER::SHIFT_2_BITS_PER_CLO
    }
    #[doc = "Checks if the value of the field is `SHIFT_4_BITS_PER_CLO`"]
    #[inline]
    pub fn is_shift_4_bits_per_clo(&self) -> bool {
        *self == PARALLEL_MODER::SHIFT_4_BITS_PER_CLO
    }
    #[doc = "Checks if the value of the field is `SHIFT_1_BYTE_PER_CLO`"]
    #[inline]
    pub fn is_shift_1_byte_per_clo(&self) -> bool {
        *self == PARALLEL_MODER::SHIFT_1_BYTE_PER_CLO
    }
}
#[doc = "Possible values of the field `INV_QUALIFIER`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum INV_QUALIFIERR {
    #[doc = "Use normal qualifier."]
    USE_NORMAL_QUALIFIER,
    #[doc = "Use inverted qualifier."]
    USE_INVERTED_QUALIFI,
}
impl INV_QUALIFIERR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            INV_QUALIFIERR::USE_NORMAL_QUALIFIER => false,
            INV_QUALIFIERR::USE_INVERTED_QUALIFI => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> INV_QUALIFIERR {
        match value {
            false => INV_QUALIFIERR::USE_NORMAL_QUALIFIER,
            true => INV_QUALIFIERR::USE_INVERTED_QUALIFI,
        }
    }
    #[doc = "Checks if the value of the field is `USE_NORMAL_QUALIFIER`"]
    #[inline]
    pub fn is_use_normal_qualifier(&self) -> bool {
        *self == INV_QUALIFIERR::USE_NORMAL_QUALIFIER
    }
    #[doc = "Checks if the value of the field is `USE_INVERTED_QUALIFI`"]
    #[inline]
    pub fn is_use_inverted_qualifi(&self) -> bool {
        *self == INV_QUALIFIERR::USE_INVERTED_QUALIFI
    }
}
#[doc = "Values that can be written to the field `MATCH_MODE`"]
pub enum MATCH_MODEW {
    #[doc = "Do not match data."]
    DO_NOT_MATCH_DATA,
    #[doc = "Match data."]
    MATCH_DATA,
}
impl MATCH_MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            MATCH_MODEW::DO_NOT_MATCH_DATA => false,
            MATCH_MODEW::MATCH_DATA => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _MATCH_MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _MATCH_MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: MATCH_MODEW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Do not match data."]
    #[inline]
    pub fn do_not_match_data(self) -> &'a mut W {
        self.variant(MATCH_MODEW::DO_NOT_MATCH_DATA)
    }
    #[doc = "Match data."]
    #[inline]
    pub fn match_data(self) -> &'a mut W {
        self.variant(MATCH_MODEW::MATCH_DATA)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 0;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `CLK_CAPTURE_MODE`"]
pub enum CLK_CAPTURE_MODEW {
    #[doc = "Use rising clock edge."]
    USE_RISING_CLOCK_EDG,
    #[doc = "Use falling clock edge."]
    USE_FALLING_CLOCK_ED,
}
impl CLK_CAPTURE_MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            CLK_CAPTURE_MODEW::USE_RISING_CLOCK_EDG => false,
            CLK_CAPTURE_MODEW::USE_FALLING_CLOCK_ED => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _CLK_CAPTURE_MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _CLK_CAPTURE_MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: CLK_CAPTURE_MODEW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Use rising clock edge."]
    #[inline]
    pub fn use_rising_clock_edg(self) -> &'a mut W {
        self.variant(CLK_CAPTURE_MODEW::USE_RISING_CLOCK_EDG)
    }
    #[doc = "Use falling clock edge."]
    #[inline]
    pub fn use_falling_clock_ed(self) -> &'a mut W {
        self.variant(CLK_CAPTURE_MODEW::USE_FALLING_CLOCK_ED)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 1;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `CLKGEN_MODE`"]
pub enum CLKGEN_MODEW {
    #[doc = "Use clock internally generated by COUNTER."]
    USE_CLOCK_INTERNALLY,
    #[doc = "Use external clock from a pin or other slice."]
    USE_EXTERNAL_CLOCK_F,
}
impl CLKGEN_MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            CLKGEN_MODEW::USE_CLOCK_INTERNALLY => false,
            CLKGEN_MODEW::USE_EXTERNAL_CLOCK_F => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _CLKGEN_MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _CLKGEN_MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: CLKGEN_MODEW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Use clock internally generated by COUNTER."]
    #[inline]
    pub fn use_clock_internally(self) -> &'a mut W {
        self.variant(CLKGEN_MODEW::USE_CLOCK_INTERNALLY)
    }
    #[doc = "Use external clock from a pin or other slice."]
    #[inline]
    pub fn use_external_clock_f(self) -> &'a mut W {
        self.variant(CLKGEN_MODEW::USE_EXTERNAL_CLOCK_F)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 2;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `INV_OUT_CLK`"]
pub enum INV_OUT_CLKW {
    #[doc = "Normal clock."]
    NORMAL_CLOCK,
    #[doc = "Inverted clock."]
    INVERTED_CLOCK,
}
impl INV_OUT_CLKW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            INV_OUT_CLKW::NORMAL_CLOCK => false,
            INV_OUT_CLKW::INVERTED_CLOCK => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _INV_OUT_CLKW<'a> {
    w: &'a mut W,
}
impl<'a> _INV_OUT_CLKW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: INV_OUT_CLKW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Normal clock."]
    #[inline]
    pub fn normal_clock(self) -> &'a mut W {
        self.variant(INV_OUT_CLKW::NORMAL_CLOCK)
    }
    #[doc = "Inverted clock."]
    #[inline]
    pub fn inverted_clock(self) -> &'a mut W {
        self.variant(INV_OUT_CLKW::INVERTED_CLOCK)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 3;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `DATA_CAPTURE_MODE`"]
pub enum DATA_CAPTURE_MODEW {
    #[doc = "Detect rising edge."]
    DETECT_RISING_EDGE,
    #[doc = "Detect falling edge."]
    DETECT_FALLING_EDGE,
    #[doc = "Detect LOW level."]
    DETECT_LOW_LEVEL,
    #[doc = "Detect HIGH level."]
    DETECT_HIGH_LEVEL,
}
impl DATA_CAPTURE_MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> u8 {
        match *self {
            DATA_CAPTURE_MODEW::DETECT_RISING_EDGE => 0,
            DATA_CAPTURE_MODEW::DETECT_FALLING_EDGE => 1,
            DATA_CAPTURE_MODEW::DETECT_LOW_LEVEL => 2,
            DATA_CAPTURE_MODEW::DETECT_HIGH_LEVEL => 3,
        }
    }
}
#[doc = r" Proxy"]
pub struct _DATA_CAPTURE_MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _DATA_CAPTURE_MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: DATA_CAPTURE_MODEW) -> &'a mut W {
        {
            self.bits(variant._bits())
        }
    }
    #[doc = "Detect rising edge."]
    #[inline]
    pub fn detect_rising_edge(self) -> &'a mut W {
        self.variant(DATA_CAPTURE_MODEW::DETECT_RISING_EDGE)
    }
    #[doc = "Detect falling edge."]
    #[inline]
    pub fn detect_falling_edge(self) -> &'a mut W {
        self.variant(DATA_CAPTURE_MODEW::DETECT_FALLING_EDGE)
    }
    #[doc = "Detect LOW level."]
    #[inline]
    pub fn detect_low_level(self) -> &'a mut W {
        self.variant(DATA_CAPTURE_MODEW::DETECT_LOW_LEVEL)
    }
    #[doc = "Detect HIGH level."]
    #[inline]
    pub fn detect_high_level(self) -> &'a mut W {
        self.variant(DATA_CAPTURE_MODEW::DETECT_HIGH_LEVEL)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 3;
        const OFFSET: u8 = 4;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `PARALLEL_MODE`"]
pub enum PARALLEL_MODEW {
    #[doc = "Shift 1 bit per clock."]
    SHIFT_1_BIT_PER_CLOC,
    #[doc = "Shift 2 bits per clock."]
    SHIFT_2_BITS_PER_CLO,
    #[doc = "Shift 4 bits per clock."]
    SHIFT_4_BITS_PER_CLO,
    #[doc = "Shift 1 byte per clock."]
    SHIFT_1_BYTE_PER_CLO,
}
impl PARALLEL_MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> u8 {
        match *self {
            PARALLEL_MODEW::SHIFT_1_BIT_PER_CLOC => 0,
            PARALLEL_MODEW::SHIFT_2_BITS_PER_CLO => 1,
            PARALLEL_MODEW::SHIFT_4_BITS_PER_CLO => 2,
            PARALLEL_MODEW::SHIFT_1_BYTE_PER_CLO => 3,
        }
    }
}
#[doc = r" Proxy"]
pub struct _PARALLEL_MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _PARALLEL_MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: PARALLEL_MODEW) -> &'a mut W {
        {
            self.bits(variant._bits())
        }
    }
    #[doc = "Shift 1 bit per clock."]
    #[inline]
    pub fn shift_1_bit_per_cloc(self) -> &'a mut W {
        self.variant(PARALLEL_MODEW::SHIFT_1_BIT_PER_CLOC)
    }
    #[doc = "Shift 2 bits per clock."]
    #[inline]
    pub fn shift_2_bits_per_clo(self) -> &'a mut W {
        self.variant(PARALLEL_MODEW::SHIFT_2_BITS_PER_CLO)
    }
    #[doc = "Shift 4 bits per clock."]
    #[inline]
    pub fn shift_4_bits_per_clo(self) -> &'a mut W {
        self.variant(PARALLEL_MODEW::SHIFT_4_BITS_PER_CLO)
    }
    #[doc = "Shift 1 byte per clock."]
    #[inline]
    pub fn shift_1_byte_per_clo(self) -> &'a mut W {
        self.variant(PARALLEL_MODEW::SHIFT_1_BYTE_PER_CLO)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 3;
        const OFFSET: u8 = 6;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `INV_QUALIFIER`"]
pub enum INV_QUALIFIERW {
    #[doc = "Use normal qualifier."]
    USE_NORMAL_QUALIFIER,
    #[doc = "Use inverted qualifier."]
    USE_INVERTED_QUALIFI,
}
impl INV_QUALIFIERW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            INV_QUALIFIERW::USE_NORMAL_QUALIFIER => false,
            INV_QUALIFIERW::USE_INVERTED_QUALIFI => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _INV_QUALIFIERW<'a> {
    w: &'a mut W,
}
impl<'a> _INV_QUALIFIERW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: INV_QUALIFIERW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Use normal qualifier."]
    #[inline]
    pub fn use_normal_qualifier(self) -> &'a mut W {
        self.variant(INV_QUALIFIERW::USE_NORMAL_QUALIFIER)
    }
    #[doc = "Use inverted qualifier."]
    #[inline]
    pub fn use_inverted_qualifi(self) -> &'a mut W {
        self.variant(INV_QUALIFIERW::USE_INVERTED_QUALIFI)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 8;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
impl R {
    #[doc = r" Value of the register as raw bits"]
    #[inline]
    pub fn bits(&self) -> u32 {
        self.bits
    }
    #[doc = "Bit 0 - Match mode. Selects whether the match filter is active or whether data is captured."]
    #[inline]
    pub fn match_mode(&self) -> MATCH_MODER {
        MATCH_MODER::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 1 - Capture clock mode"]
    #[inline]
    pub fn clk_capture_mode(&self) -> CLK_CAPTURE_MODER {
        CLK_CAPTURE_MODER::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 1;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 2 - Clock generation mode. Selects the clock generated by the slice counter or by an external pin or other slice as shift clock."]
    #[inline]
    pub fn clkgen_mode(&self) -> CLKGEN_MODER {
        CLKGEN_MODER::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 2;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 3 - Invert output clock"]
    #[inline]
    pub fn inv_out_clk(&self) -> INV_OUT_CLKR {
        INV_OUT_CLKR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 3;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bits 4:5 - Condition for input bit match interrupt"]
    #[inline]
    pub fn data_capture_mode(&self) -> DATA_CAPTURE_MODER {
        DATA_CAPTURE_MODER::_from({
            const MASK: u8 = 3;
            const OFFSET: u8 = 4;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        })
    }
    #[doc = "Bits 6:7 - Parallel mode"]
    #[inline]
    pub fn parallel_mode(&self) -> PARALLEL_MODER {
        PARALLEL_MODER::_from({
            const MASK: u8 = 3;
            const OFFSET: u8 = 6;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        })
    }
    #[doc = "Bit 8 - Inversion qualifier"]
    #[inline]
    pub fn inv_qualifier(&self) -> INV_QUALIFIERR {
        INV_QUALIFIERR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 8;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
}
impl W {
    #[doc = r" Reset value of the register"]
    #[inline]
    pub fn reset_value() -> W {
        W { bits: 0 }
    }
    #[doc = r" Writes raw bits to the register"]
    #[inline]
    pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
        self.bits = bits;
        self
    }
    #[doc = "Bit 0 - Match mode. Selects whether the match filter is active or whether data is captured."]
    #[inline]
    pub fn match_mode(&mut self) -> _MATCH_MODEW {
        _MATCH_MODEW { w: self }
    }
    #[doc = "Bit 1 - Capture clock mode"]
    #[inline]
    pub fn clk_capture_mode(&mut self) -> _CLK_CAPTURE_MODEW {
        _CLK_CAPTURE_MODEW { w: self }
    }
    #[doc = "Bit 2 - Clock generation mode. Selects the clock generated by the slice counter or by an external pin or other slice as shift clock."]
    #[inline]
    pub fn clkgen_mode(&mut self) -> _CLKGEN_MODEW {
        _CLKGEN_MODEW { w: self }
    }
    #[doc = "Bit 3 - Invert output clock"]
    #[inline]
    pub fn inv_out_clk(&mut self) -> _INV_OUT_CLKW {
        _INV_OUT_CLKW { w: self }
    }
    #[doc = "Bits 4:5 - Condition for input bit match interrupt"]
    #[inline]
    pub fn data_capture_mode(&mut self) -> _DATA_CAPTURE_MODEW {
        _DATA_CAPTURE_MODEW { w: self }
    }
    #[doc = "Bits 6:7 - Parallel mode"]
    #[inline]
    pub fn parallel_mode(&mut self) -> _PARALLEL_MODEW {
        _PARALLEL_MODEW { w: self }
    }
    #[doc = "Bit 8 - Inversion qualifier"]
    #[inline]
    pub fn inv_qualifier(&mut self) -> _INV_QUALIFIERW {
        _INV_QUALIFIERW { w: self }
    }
}
